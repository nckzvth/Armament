# Persistence

Durable progression now uses PostgreSQL with EF Core migrations in:
- `/Users/nckzvth/Projects/Armament/server-dotnet/Src/Persistence`

## Schema

- `accounts`: account identity (`UNIQUE(external_subject)`)
- `account_characters`: account -> character slot mapping (`UNIQUE(account_id, slot_index)`, `UNIQUE(account_id, character_id)`)
- `characters`: durable character context (level/xp/attributes/derived caps/currency + JSON payloads for gear/inventory/recipes/quest progress)
- `inventory_items`: normalized item stack rows (`UNIQUE(character_id, item_code)`)
- `quest_progress`: quest counters (`UNIQUE(character_id, quest_code)`)
- `learned_recipes`: unlocked recipes (`UNIQUE(character_id, recipe_code)`)
- `loot_claims`: idempotency/anti-dupe table (`UNIQUE(pickup_token)`)

## Migrations

- EF migration assembly is in `/Users/nckzvth/Projects/Armament/server-dotnet/Src/Persistence/Migrations`
- Apply with `PersistenceModule.ApplyMigrationsAsync(...)` or `dotnet ef database update` from the persistence project.
- Migrations are generated by EF tooling, not hand-authored SQL.

## Transactional Loot Grant

- `LootTransactionService.TryGrantLootAsync(...)` performs:
1. insert loot claim (`pickup_token`) inside a DB transaction
2. reject duplicate claim on unique violation
3. mutate character currency and inventory in the same transaction
4. commit atomically

This prevents duplicate rewards from repeated pickup intents.

## Non-Blocking Server Integration

- Authoritative server integration path:
  - sim emits `SimLootGrantEvent` during tick step
  - zone copies events to `LastLootGrantEvents`
  - `AuthoritativeServer` enqueues each event into `BoundedLootPersistenceQueue`
  - queue worker writes to persistence with retries
- Queue behavior:
  - bounded capacity
  - non-blocking enqueue from tick thread
  - retry with capped attempts
  - drop accounting for backpressure visibility
- Runtime toggle:
  - set `ARMAMENT_DB_CONNECTION` to enable live persistence queue in `ServerHost`
  - if unset, server runs without persistence writes (gameplay still works)

## Authoritative Character Load on Join

- Join flow with persistence enabled:
  - join request includes `accountSubject`, `accountDisplayName`, `characterSlot`, `characterName`
  - profile worker resolves account and slot mapping
  - `character_id` is stable from (`accountSubject`, `characterSlot`)
  - `ICharacterProfileService` loads profile asynchronously (or creates default if missing)
  - first-time slot usage auto-creates and binds character to account slot
  - server accepts join only after profile result is available
  - zone applies loaded level/xp/currency/attributes before first snapshot
- This keeps DB I/O off the authoritative tick thread while making reconnect state durable.

## Integration Testing

- Persistence integration test entrypoint:
  - `dotnet run --project /Users/nckzvth/Projects/Armament/server-dotnet/Tests/Persistence.Tests/Armament.Persistence.Tests.csproj`
- Test strategy:
  - Prefer Testcontainers (`postgres:16-alpine`) for hermetic CI.
  - Fallback: set `ARMAMENT_TEST_DB_CONNECTION` to run against an explicit local PostgreSQL instance.
  - If neither Docker nor external DB is available, test fails by default.
  - Set `ARMAMENT_ALLOW_PERSISTENCE_SKIP=1` only for temporary local bypass.
